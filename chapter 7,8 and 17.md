Brandon Sanchez 
008183650

I wrote this HW assignment in Markdown using obsidian for easier to read and grade my assignment.
 

## 7.4 Problem
Create the symbol table entries generated by the assembly language  for the given LC-3 assembly code.

---

## Code Analysis

### **Provided Code**

```assembly
.ORIG x301C
ST R3, SAVE3
ST R2, SAVE2
AND R2, R2, #0
TEST    IN
        BRz TEST
        ADD R1, R0, #-10
        BRn FINISH
        ADD R1, R0, #-15
        NOT R1, R1
        BRn FINISH
        HALT
FINISH  ADD R2, R2, #1
        HALT
SAVE3   .FILL x0000
SAVE2   .FILL x0000
.END
```


---

## Solution 


---

 **Analyzing the Program**
   - Instructions:
     - `ST R3, SAVE3`: At address `x301C`
     - `ST R2, SAVE2`: At address `x301D`
     - `AND R2, R2, #0`: At address `x301E`
   - Label `TEST`:
     - Points to address `x301F` because the next instruction `IN` starts here.
   
     - `BRz TEST`: At address `x3020`
   
     - `ADD R1, R0, #-10`: At address `x3021`
     - `BRn FINISH`: At address `x3022`
     - `ADD R1, R0, #-15`: At address `x3023`
     - `NOT R1, R1`: At address `x3024`
   - Label `FINISH`:
     - Points to address `x3025` because the `ADD R2, R2, #1` starts here.
   - Variables:
     - `SAVE3 .FILL X0000`: At address `x3027`
     - `SAVE2 .FILL X0000`: At address `x3028`

---

###  **Constructing the Symbol Table**
   - For each label, its is associated with its own corresponding memory address 
---

## Final Symbol Table

| Label   | Address |
|---------|---------|
| TEST    | x301F   |
| FINISH  | x3025   |
| SAVE3   | x3027   |
| SAVE2   | x3028   |

---

## 7.5 Problem Context

look at the assembly and determine what its operation is


---

## Steps to Analyze the Program

 **Identify Constants and Initializations**
   - `.ORIG x3000`: The program begins at address `x3000`.
   - The following initializations load values into registers:
     - `LD R2, ZERO`: Load `x0000` into register `R2`.
     - `LD R0, M0`: Load the value at label `M0` (`x0004`) into register `R0`.
     - `LD R1, M1`: Load the value at label `M1` (`x0803`) into register `R1`.

 **Understand the Loop Structure**
   - Label `LOOP`:
     - `BRz DONE`: If `R1` is zero, branch to `DONE`.
     - `ADD R2, R2, R0`: Add the value in `R0` to `R2` and store the result in `R2`.
     - `ADD R1, R1, -1`: Subtract `1` from `R1`.
     - `BR LOOP`: Go back to the `LOOP` label.

**Exit Condition and Final Operation**
   - Label `DONE`:
     - `ST R2, RESULT`: Store the value in `R2` into the memory location labeled `RESULT`.
     - `HALT`: Stop program execution.

 **Analyze the Constants**
   - `RESULT .FILL x0000`: Placeholder to store the result.
   - `ZERO .FILL x0000`: Represents the value `0`.
   - `M0 .FILL x0004`: Represents the multiplier (`4`).
   - `M1 .FILL x0803`: Represents the multiplicand (`803` in decimal).

---

**Trace Execution**
   - **Initialization:**
     - `R2 = 0` (from `ZERO`).
     - `R0 = 4` (from `M0`).
     - `R1 = 0x0803` (from `M1`, 2051 in decimal).
   - **Loop Execution:**
     - The loop runs as long as `R1` is not zero.
     - Each iteration:
       - Adds `4` (value of `R0`) to `R2`.
       - Decrements `R1` by `1`.
     - The loop executes `2051` times (value of `M1`), effectively multiplying `4 * 2051`.
   - **Result:**
     - Final value of `R2` is `4 * 2051 = 8204`.
     - This value is stored in `RESULT`.

---


## 7.9 Problem Context

This problem prompts about the what does a `.END` file do in assembly and how it differs when using a `HALT` function


---


**Understanding the `.END` Pseudo-op**
   - The `.END` pseudo-op indicates the end of the assembly source code.
   - In short it tells the assembler that the code ends here so that it finishes compiling like a return 0 in C++

---

**Understanding the `HALT` Instruction**
   
   - `HALT` similar to the `.END`  instruction however it only stop the execution of a program during runtime


---

## 8.1 Problem Context
The question asks about the defining characteristics of a stack.

which is a fundamental data structure in programming  which is linear and follows a last in , first out principle LIFO


---

## 8.8 Problem Context

This question is the sequences of stakc operations and analyzing it on various points. 

---

## Solution

### **a. What does the stack contain after the `PUSH F`?**

#### Steps:
`PUSH A`: Stack = [A]
 `PUSH B`: Stack = [A, B]
 `POP`: Remove B → Stack = [A]
 `PUSH C`: Stack = [A, C]
 `PUSH D`: Stack = [A, C, D]
 `POP`: Remove D → Stack = [A, C]
 `PUSH E`: Stack = [A, C, E]
 `POP`: Remove E → Stack = [A, C]
 `POP`: Remove C → Stack = [A]
 `PUSH F`: Stack = [A, F]

#### **Answer (a):**
After `PUSH F`, the stack contains: **[A, F]**.

---

### **b. At which point does the stack contain the most elements?**


Without clearing the stack, additional operations are performed:

Initial state: Stack = [A, F]
`PUSH G`: Stack = [A, F, G]
`PUSH H`: Stack = [A, F, G, H]
`PUSH I`: Stack = [A, F, G, H, I]
 `PUSH J`: Stack = [A, F, G, H, I, J] → **Maximum = 6 elements**
`POP`: Remove J → Stack = [A, F, G, H, I]
 `PUSH K`: Stack = [A, F, G, H, I, K]
`POP`: Remove K → Stack = [A, F, G, H, I]
`POP`: Remove I → Stack = [A, F, G, H]
`POP`: Remove H → Stack = [A, F, G]
`PUSH L`: Stack = [A, F, G, L]
`POP`: Remove L → Stack = [A, F, G]
`PUSH M`: Stack = [A, F, G, M]

#### **Answer (b):**
The stack contains the most elements (6) after `PUSH J`.

---

### **c. What does the stack contain now?**

#### Steps (continued from part b):
 Final state after `PUSH M`: Stack = [A, F, G, M]

#### **Answer (c):**
The stack now contains: **[A, F, G, M]**.

---

## 9.5 Problem Context

What is the sole purpose of a bit 15 Keyboard Status Register (KBSR) which is part of the I/O system of LC-3 to indicate keystrokes.  


---

## Solution

 **What is the KBSR?**
   - The **Keyboard Status Register (KBSR)** a memory mapped register to indicate keystrokes

---

### 2. **Role of Bit [15] in the KBSR**

The bit 15 part of the `KBSR` is to signal when its ready for availability to be read from the keyboard 

   - The status of this bit:
     - **1**: A character is available, and the program can read it.
     - **0**: No character is available; the keyboard buffer is empty.

---

## 17.1 Problem Context

This means that analyzing the  number of calls to recursive function of RunningSum for specific inputs. 


---

## Solution

### **a. How many calls to `RunningSum` are made for `RunningSum(10)`?**

Analysis:
- The function `RunningSum(n)` is likely defined recursively, with each call reducing `n` by `1` until a base case (e.g., `n == 0`) is reached.
- For each value of `n`, there is one call to `RunningSum(n)`, followed by a call to `RunningSum(n-1)`, and so on, until `RunningSum(0)`.

Total Calls:
- For `RunningSum(10)`, the sequence of calls is:
  - `RunningSum(10)`, `RunningSum(9)`, `RunningSum(8)`, ..., `RunningSum(0)`.
- This results in **11 calls** (from `10` down to `0`).

 **Answer (a):** **11 calls**

---

### **b. How many calls are made for `RunningSum(n)`?**

Analysis:
- Using the same reasoning as part (a):

For `RunningSum(n)`, the function makes calls for `n`, `n-1`, ..., down to `0`.

This produces a total of `n + 1` calls, as there are `n` recursive calls plus the base case.

**Answer (b):** **n + 1 calls**

---

## Final Answers
- **a.** For `RunningSum(10)`: **11 calls**
- **b.** For `RunningSum(n)`: **n + 1 calls**
