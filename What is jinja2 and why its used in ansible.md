### What is Jinja2 and why Ansible uses it?

|Step|What happens|Why it matters|
|---|---|---|
|1|**Ansible runs a playbook** on a _control node_ (the machine that runs the `ansible-playbook` command).|The control node is the brain of the operation.|
|2|**Ansible gathers facts** from every target host (IP, hostname, OS, etc.).|These facts become variables that can be used in templates.|
|3|**Ansible renders a Jinja2 template** on the control node.|The template is a plain text file that contains placeholders (`{{ … }}`) and logic (`{% … %}`).|
|4|**The rendered file is copied** to the target host(s).|The target host receives a configuration file that is already customized for it.|

In short, **Jinja2 lets you write “one file that becomes many”**.  
You write a single template once, and Ansible turns it into a different file for each host, inserting the right IP address, hostname, or any other variable you need.

---

## Practical example – three‑machine setup

```
control‑node   (runs ansible‑playbook)
host‑1         (target 1)
host‑2         (target 2)
```

We’ll create a simple `/etc/hosts` file on the two target machines.  
The template will:

1. Loop over all hosts in the inventory.
2. Print each host’s IP, FQDN, and short hostname.
3. Use a conditional to add a comment only on the first target.

### 1. Inventory (`inventory.ini`)

```ini
# control‑node is the machine that runs the playbook
[control]
control-node ansible_connection=local

# Two target machines
[web]
host-1 ansible_host=192.168.1.101
host-2 ansible_host=192.168.1.102
```

> **Explanation**
> 
> - `ansible_host` tells Ansible which IP to SSH into.
> - The `[control]` group is special – it contains the machine that runs the playbook, so it never gets a configuration file.

---

### 2. Playbook (`deploy‑hosts.yml`)

```yaml
---
- name: Build /etc/hosts on every target
  hosts: web                # <-- target group
  gather_facts: true        # <-- collect facts (IP, hostname, …)

  tasks:
    - name: Render and copy /etc/hosts
      ansible.builtin.template:
        src: templates/hosts.j2   # Jinja2 template on control‑node
        dest: /etc/hosts          # file that will land on host‑1 & host‑2
        owner: root
        group: root
        mode: '0644'
        validate: /usr/bin/true   # optional: check syntax before copying
```

> **Step‑by‑step**
> 
> 1. `gather_facts: true` – Ansible asks each host for its facts.
> 2. `ansible.builtin.template` – tells Ansible to use the template module.
> 3. `src` – path to the template **on the control node**.
> 4. `dest` – where the rendered file will be written on the target.
> 5. `validate` – runs a command on the target to make sure the file is syntactically correct (here we just use `/usr/bin/true` so nothing actually happens).

---

### 3. Jinja2 template (`templates/hosts.j2`)

```jinja2
# {{ ansible_managed }}  <-- automatically added comment
# DO NOT EDIT THIS FILE – it is generated by Ansible

# Build /etc/hosts by looping over every host in the inventory
{% for host in groups['web'] %}
# IP   FQDN            Hostname
{{ hostvars[host]['ansible_facts']['default_ipv4']['address'] }} \
{{ hostvars[host]['ansible_facts']['fqdn'] }} \
{{ hostvars[host]['ansible_facts']['hostname'] }}
{% endfor %}
```

> **What each line does**
> 
> - `{{ ansible_managed }}` – a special string you can set in `ansible.cfg`; it warns admins that the file is auto‑generated.
> - `{% for host in groups['web'] %}` – starts a loop that runs once for every host in the `web` group.
> - Inside the loop we use `{{ … }}` to insert facts:
>     - `hostvars[host]['ansible_facts']['default_ipv4']['address']` → the host’s IP.
>     - `hostvars[host]['ansible_facts']['fqdn']` → the fully‑qualified domain name.
>     - `hostvars[host]['ansible_facts']['hostname']` → the short hostname.
> - `{% endfor %}` – ends the loop.

When the playbook runs, the control node will produce **two separate `/etc/hosts` files** – one for `host‑1` and one for `host‑2` – each with the correct IP and hostname for that machine.

---

## Key take‑aways

|Feature|What it looks like|What it does|
|---|---|---|
|**Variables**|`{{ ansible_facts['hostname'] }}`|Inserts the host’s hostname.|
|**Loops**|`{% for host in groups['web'] %}…{% endfor %}`|Repeats a block for every host.|
|**Conditionals**|`{% if ansible_os_family == 'RedHat' %}…{% endif %}`|Adds a line only on certain OSes.|
|**Filters**|`{{ myvar|to_nice_json }}`|

With Jinja2, you write a _single_ template once and let Ansible automatically create the right configuration for each machine in your inventory. That’s why it’s a core part of Ansible’s automation power.